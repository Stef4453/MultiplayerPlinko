<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plinko Multiplayer</title>
    <!-- Matter.js for physics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Ably for Realtime Messaging Relay -->
    <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
    <style>
        :root {
            --bg-color: #0d1e29;
            --panel-color: #1a2c38;
            --accent-color: #00e701;
            --ball-color: #ff4d4d;
            --text-color: #ffffff;
            --secondary-text: #b1bad3;
            --peg-color: #4a6a7d;
            --obstacle-color: #c7254e;
            --input-bg: #0f212e;
            --gold-color: #ffca28;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* Lobby & General UI */
        #lobby-screen {
            position: fixed;
            inset: 0;
            background: var(--bg-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .lobby-card {
            background: var(--panel-color);
            padding: 20px;
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            border: 1px solid #2f4553;
            text-align: center;
        }

        .input-box {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            border: 2px solid #2f4553;
            background: var(--input-bg);
            color: white;
            box-sizing: border-box;
            font-size: 1rem;
        }

        /* Game Structure */
        .game-container {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: row;
        }

        .side-panel {
            width: 320px;
            background: #213743;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            border-right: 1px solid #2f4553;
            overflow-y: auto;
        }

        .board-container {
            flex: 1;
            position: relative;
            background: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        /* Player List */
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #1a2c38;
            border-radius: 8px;
            margin-bottom: 8px;
            border: 1px solid transparent;
            transition: all 0.3s;
        }

        .player-item.active {
            border-color: var(--accent-color);
            box-shadow: 0 0 10px rgba(0, 231, 1, 0.2);
        }

        .player-item.eliminated {
            background: #0d1e29;
            border: 1px dashed rgba(255, 255, 255, 0.1);
        }

        /* Round Header */
        .round-info {
            text-align: center;
            margin-bottom: 10px;
        }

        .round-badge {
            background: var(--accent-color);
            color: #000;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: 900;
            text-transform: uppercase;
        }

        /* Bins */
        #canvas-wrapper {
            position: relative;
            width: 700px;
            height: 600px;
        }

        .bins-container {
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 2px;
            padding: 0 10px;
            pointer-events: none;
        }

        .bin {
            flex: 1;
            min-width: 0;
            height: 35px;
            background: #2f4553;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem;
            font-weight: 800;
            color: #fff;
            transition: transform 0.1s;
            overflow: hidden;
            white-space: nowrap;
        }

        .bin.active {
            background: var(--accent-color) !important;
            color: #000;
            transform: scale(1.1);
        }

        /* Responsive UI */
        @media (max-width: 900px) {
            .game-container {
                flex-direction: column;
                overflow-y: auto;
            }

            .side-panel {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #2f4553;
                box-sizing: border-box;
            }

            #canvas-wrapper {
                width: 100% !important;
                max-width: 700px;
                height: auto !important;
                aspect-ratio: 7/6;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
            }

            .board-container {
                padding: 10px;
                width: 100%;
                box-sizing: border-box;
            }

            .side-panel {
                padding: 10px;
                gap: 10px;
            }

            #my-score {
                font-size: 1.5rem !important;
            }

            .player-item {
                padding: 8px;
                font-size: 0.9rem;
            }
        }

        /* Floating Text Animations */
        @keyframes float-up {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }

        .floating-text {
            position: absolute;
            pointer-events: none;
            font-weight: 900;
            animation: float-up 1s forwards;
            z-index: 100;
        }

        .gold-win {
            color: #ffca28;
            text-shadow: 0 0 10px rgba(255, 202, 40, 0.5);
            font-size: 2rem;
        }

        .green-win {
            color: #00e701;
            font-size: 1.2rem;
        }

        .loss-text {
            color: #ff4d4d;
            font-size: 1rem;
        }

        /* Buttons */
        button {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
        }

        .btn-primary {
            background: var(--accent-color);
            color: #000;
        }

        .btn-secondary {
            background: #2f4553;
            color: white;
        }

        button:disabled {
            background: #111;
            color: #444;
            cursor: not-allowed;
        }

        #room-id-display {
            background: #0d1e29;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            margin: 10px 0;
            display: block;
            word-break: break-all;
        }

        .risk-presets {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 5px;
        }

        .risk-presets button {
            padding: 8px;
            font-size: 0.7rem;
            border-radius: 4px;
        }

        /* Custom Alert */
        .alert-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
        }

        .alert-card {
            background: var(--panel-color);
            padding: 30px;
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
            border: 2px solid var(--accent-color);
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 231, 1, 0.2);
            animation: modal-pop 0.3s ease-out;
        }

        @keyframes modal-pop {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .alert-title {
            color: var(--accent-color);
            font-size: 1.5rem;
            margin-bottom: 15px;
            font-weight: 900;
            text-transform: uppercase;
        }

        .alert-msg {
            color: white;
            margin-bottom: 25px;
            line-height: 1.6;
        }
    </style>
</head>

<body>

    <div id="lobby-screen">
        <div class="lobby-card">
            <h1>Plinko Multiplayer</h1>
            <input type="text" id="name-input" class="input-box" placeholder="Your Name" maxlength="12">
            <div id="pre-room">
                <div style="margin: 10px 0; display: flex; align-items: center; gap: 10px; justify-content: center;">
                    <label for="max-players-input" style="color: #ccc; font-size: 0.9em;">Max Players:</label>
                    <input type="number" id="max-players-input" min="2" max="16" value="8"
                        style="width: 60px; padding: 8px; text-align: center;">
                </div>
                <button onclick="hostGame()" class="btn-primary" style="width: 100%">Host New Game</button>
                <div style="margin: 15px 0; color: var(--secondary-text)">â€” OR â€”</div>
                <div style="display: flex; align-items: center; gap: 8px; margin: 10px 0;">
                    <span
                        style="font-size: 1.2rem; font-weight: bold; color: var(--secondary-text); font-family: monospace;">PR-</span>
                    <input type="text" id="join-room-id" class="input-box" placeholder="Enter Code"
                        style="margin: 0; flex: 1;">
                </div>
                <button onclick="joinGame()" class="btn-secondary" style="width: 100%">Join Game</button>
            </div>
            <div id="wait-room" style="display: none;">
                <p>Room ID: <span id="room-id-display">Generating...</span></p>
                <p id="player-count">Players: 1/8</p>

                <!-- Lobby Player List -->
                <div id="lobby-player-list" style="margin: 15px 0; max-height: 200px; overflow-y: auto;">
                    <!-- Players will be listed here -->
                </div>

                <button onclick="startGame()" id="start-game-btn" class="btn-primary"
                    style="background: #00e701; color: #000; margin-top: 15px;">START GAME</button>
            </div>
        </div>
    </div>

    <div
        style="position: fixed; bottom: 10px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 0.8rem; pointer-events: none; z-index: 9999;">
        Plinko Multiplayer. Vibe Coded by Stef using Antigravity. <a
            href="https://github.com/Stef4453/MultiplayerPlinko" target="_blank"
            style="color: rgba(255,255,255,0.8); text-decoration: none; pointer-events: auto;">GitHub Repo</a>
    </div>

    <div class="game-container" id="main-game">
        <div class="side-panel">
            <div class="round-info">
                <div class="round-badge" id="diff-badge">EASY</div>
                <h2 id="round-number">ROUND 1</h2>
                <div id="game-room-id"
                    style="font-size: 0.8rem; color: var(--secondary-text); margin-top: 5px; font-family: monospace;">
                    ROOM: ----</div>
            </div>

            <div id="player-list">
                <!-- Syncing players here -->
            </div>

            <div style="margin-top: auto;">
                <div class="label">Your Points</div>
                <div id="my-score" style="font-size: 2rem; font-weight: 900; color: var(--accent-color);">1000</div>

                <div class="control-group" style="margin-top: 15px;">
                    <div class="label">Amount to Risk</div>
                    <div style="display: flex; gap: 8px;">
                        <input type="number" id="risk-input" class="input-box" value="10" min="10"
                            style="margin: 0; flex: 1;">
                        <button onclick="setRisk(1)" class="btn-secondary" style="padding: 10px;">MAX</button>
                    </div>
                    <div class="risk-presets">
                        <button onclick="setRisk(2)" class="btn-secondary">1/2</button>
                        <button onclick="setRisk(4)" class="btn-secondary">1/4</button>
                        <button onclick="setRisk(8)" class="btn-secondary">1/8</button>
                    </div>
                </div>
                <button id="drop-btn" onclick="emitDrop()" class="btn-primary"
                    style="width: 100%; margin-top: 10px;">DROP!</button>
            </div>
        </div>

        <div class="board-container">
            <div id="status-text"
                style="margin-bottom: 10px; color: var(--secondary-text); font-weight: bold; background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 20px;">
                Waiting for players...</div>
            <div id="canvas-wrapper">
                <div class="bins-container" id="bins-row"></div>
            </div>
        </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="custom-alert" class="alert-overlay">
        <div class="alert-card">
            <div class="alert-title">Notification</div>
            <div id="alert-msg" class="alert-msg">Message goes here.</div>
            <button onclick="closeAlert()" class="btn-primary" style="width: 100%">OK</button>
        </div>
    </div>

    <script>
        // --- State & Config ---
        const config = {
            width: 700,
            height: 600,
            pegSize: 5,
            ballSize: 7,
            multipliers: {
                8: [5.6, 2.1, 1.1, 0.5, 0.2, 0.5, 1.1, 2.1, 5.6],
                12: [33, 11, 4.4, 2.1, 1.1, 0.5, 0.2, 0.5, 1.1, 2.1, 4.4, 11, 33],
                16: [110, 41, 10, 5, 3, 1.5, 1, 0.5, 0.2, 0.5, 1, 1.5, 3, 5, 10, 41, 110],
                // Specific Overrides
                insane: [110, 41, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.2, 0.5, 1, 2, 5, 10, 41, 110],
                impossible: [1000, 500, 100, 10, 2, 0.5, 0.2, 0.1, 0.1, 0.1, 0.2, 0.5, 2, 10, 100, 500, 1000]
            }
        };

        // DON'T EVEN BOTHER STEALING IT - YOU WON'T BE ABLE TO DO MUCH WITH IT ANYWAY LOL -Stef
        const ABLY_KEY = 'Wwc3Hw.ZDnKdg:aX6tvLkW4-tIKleXroX-f4YacnGk5uNzEmMrJ3q13D8';
        let ably, channel;

        // ... variables ...
        let myId;
        let myName = "Player";
        let isHost = false;
        let players = [];
        let gameActive = false;
        let turnIndex = 0;
        let currentRound = 1;
        let currentObstacles = [];
        let activeTimeouts = [];
        let lastInitedRows = 0;
        let lastInitedRound = 0;
        let maxPlayersLimit = 8;

        // --- Persistent Matter.js Engine ---
        const { Engine, Render, Runner, Bodies, Composite, World, Events } = Matter;
        const engine = Engine.create();
        engine.world.gravity.y = 1.0;
        const runner = Runner.create();
        let render;

        // Initialize Renderer immediately (Persistent)
        window.addEventListener('load', () => {
            const cw = document.getElementById('canvas-wrapper');
            render = Render.create({
                element: cw,
                engine: engine,
                options: { width: config.width, height: config.height, wireframes: false, background: 'transparent' }
            });
            Render.run(render);
            Runner.run(runner, engine);
        });

        // --- Networking (Ably) ---
        function hostGame() {
            const nameInput = document.getElementById('name-input');
            myName = nameInput.value.trim();
            if (!myName) return showAlert("Please enter your name first!", "Hold up!");

            const val = parseInt(document.getElementById('max-players-input').value);
            maxPlayersLimit = (val && val >= 2) ? val : 8;

            const roomCode = generateShortId();
            nameInput.style.display = 'none'; // Lock in name
            initAbly(roomCode, true);
        }

        function joinGame() {
            const nameInput = document.getElementById('name-input');
            const roomInput = document.getElementById('join-room-id');
            let rawCode = roomInput.value.trim().toUpperCase();

            if (!rawCode) return showAlert("Please enter a Room ID", "Join Error");

            // Automatically handle if player puts PR- themselves
            let roomCode = rawCode.startsWith('PR-') ? rawCode : 'PR-' + rawCode;

            myName = nameInput.value.trim();
            if (!myName) return showAlert("Please enter your name first!", "Hold up!");

            nameInput.style.display = 'none'; // Lock in name
            initAbly(roomCode, false);
        }

        function initAbly(roomCode, hosting) {
            isHost = hosting;
            myId = Math.random().toString(36).substr(2, 9);
            console.log("Initializing Ably. ID:", myId, "Host:", isHost);

            ably = new Ably.Realtime({ key: ABLY_KEY, clientId: myId });
            channel = ably.channels.get(`plinko_${roomCode}`);

            channel.attach((err) => {
                if (err) console.error("Attachment failed:", err);
                else console.log("Channel Attached.");
            });

            ably.connection.on('connected', () => {
                console.log("Ably Connected.");

                if (hosting) {
                    isHost = true;
                    myName = getUniqueName(myName);
                    document.getElementById('room-id-display').innerText = roomCode;
                    document.getElementById('pre-room').style.display = 'none';
                    document.getElementById('wait-room').style.display = 'block';
                    players = [{ id: myId, name: myName, points: 1000, isHost: true, alive: true, joinedAt: Date.now() }];
                    updatePlayerList();
                }

                channel.subscribe(msg => {
                    if (msg.clientId === myId) return;
                    handleMessage(msg.data);
                });

                // --- PROPER PRESENCE HANDLING ---
                channel.presence.subscribe('enter', member => {
                    console.log("PRESENCE ENTER:", member.clientId, member.data);
                    if (isHost) broadcastPlayers();
                });

                channel.presence.subscribe('leave', member => {
                    console.log("PRESENCE LEAVE:", member.clientId, member.data);
                    if (isHost) {
                        handleDisconnect(member.clientId);
                    } else {
                        const isHostLeaving = (member.data && member.data.isHost) ||
                            players.some(p => p.isHost && p.id === member.clientId);
                        if (isHostLeaving) {
                            showAlert("Host left. Connection terminated.", "Room Closed", () => location.reload());
                        }
                    }
                });

                channel.presence.enter({ name: myName, isHost: isHost }, (err) => {
                    if (err) console.error("Presence Enter Error:", err);
                });

                // Host-side Sync (Aggressive)
                if (hosting) {
                    setInterval(() => {
                        if (channel) broadcast({ type: 'heartbeat' });
                    }, 15000);

                    setInterval(() => {
                        console.log("GUARD: Running presence check...");
                        channel.presence.get({ waitForSync: true }, (err, members) => {
                            if (err) {
                                console.error("GUARD: Error getting presence:", err);
                                return;
                            }
                            if (!members) {
                                console.warn("GUARD: No members returned");
                                return;
                            }

                            const activeIds = members.map(m => m.clientId);
                            console.log("GUARD: Active IDs from Ably:", activeIds);
                            console.log("GUARD: Current player IDs:", players.map(p => p.id));

                            // Safety: host must see themselves to trust the list
                            if (!activeIds.includes(myId)) {
                                console.warn("GUARD: Host not in presence list, skipping check");
                                return;
                            }

                            // Check each player against the presence list
                            for (let i = players.length - 1; i >= 0; i--) {
                                const p = players[i];
                                if (p.isHost) continue;

                                const gracePeriod = Date.now() - (p.joinedAt || 0);
                                if (gracePeriod < 15000) {
                                    console.log(`GUARD: Player ${p.id} in grace period (${gracePeriod}ms)`);
                                    continue;
                                }

                                if (!activeIds.includes(p.id)) {
                                    console.warn("GUARD: Player missing from presence, disconnecting:", p.id, p.name);
                                    handleDisconnect(p.id);
                                }
                            }
                        });
                    }, 5000);
                }

                window.addEventListener('beforeunload', () => { if (channel) channel.presence.leave(); });

                if (!hosting) {
                    broadcast({ type: 'join', name: myName, id: myId });
                    document.getElementById('pre-room').style.display = 'none';
                    document.getElementById('wait-room').style.display = 'block';
                    document.getElementById('start-game-btn').style.display = 'none';
                    document.getElementById('room-id-display').innerText = roomCode;
                    // Also show room code in game screen for later
                    const gameRoomId = document.getElementById('game-room-id');
                    if (gameRoomId) gameRoomId.innerText = `ROOM: ${roomCode}`;
                    updatePlayerList();
                } else {
                    // Host also shows room code in game screen
                    const gameRoomId = document.getElementById('game-room-id');
                    if (gameRoomId) gameRoomId.innerText = `ROOM: ${roomCode}`;
                }
            });

            ably.connection.on('failed', () => showAlert("Ably Connection Failed", "Connection Error"));
        }

        function handleMessage(data) {
            switch (data.type) {
                case 'join':
                    if (isHost) {
                        if (players.length >= maxPlayersLimit) {
                            broadcast({ type: 'error', msg: "Room is full!", targetId: data.id });
                            return;
                        }
                        const newName = getUniqueName(data.name);

                        // If game is active, join as spectator (alive: false, low points)
                        if (gameActive) {
                            players.push({ id: data.id, name: newName, points: 0, isHost: false, alive: false, joinedAt: Date.now() });
                            broadcast({ type: 'spectator_join', name: newName });
                        } else {
                            players.push({ id: data.id, name: newName, points: 1000, isHost: false, alive: true, joinedAt: Date.now() });
                        }

                        broadcastPlayers();
                        updatePlayerList();

                        // Send current game state to new joiner
                        if (gameActive) {
                            broadcast({ type: 'sync_round', round: currentRound, turnIndex, obstacles: currentObstacles });
                        }
                    }
                    break;
                case 'spectator_join':
                    // Notify existing players that someone joined as spectator
                    console.log(`${data.name} joined as spectator`);
                    break;
                case 'heartbeat':
                    // Keep-alive message to maintain active connection
                    break;
                case 'players':
                    players = data.players;
                    if (data.maxPlayers) maxPlayersLimit = data.maxPlayers;
                    updatePlayerList();
                    break;
                case 'start':
                    gameActive = true;
                    currentObstacles = data.obstacles || [];
                    turnIndex = data.turnIndex !== undefined ? data.turnIndex : 0;
                    document.getElementById('lobby-screen').style.display = 'none';
                    document.getElementById('main-game').style.display = 'flex';
                    initGame(true);
                    updateTurnUI();
                    break;
                case 'sync_round':
                    currentRound = data.round;
                    turnIndex = data.turnIndex;
                    currentObstacles = data.obstacles || [];

                    // If we're still in lobby, transition to game (for mid-game joins)
                    if (document.getElementById('lobby-screen').style.display !== 'none') {
                        gameActive = true;
                        document.getElementById('lobby-screen').style.display = 'none';
                        document.getElementById('main-game').style.display = 'flex';
                    }

                    initGame();
                    updateTurnUI();
                    break;
                case 'drop_ball':
                    if (isHost) {
                        handleDropLogic(data.x, data.playerId, data.points);
                    } else {
                        visualizeDrop(data.x, data.playerId, data.points);
                    }
                    break;
                case 'score_update':
                    const p = players.find(x => x.id === data.playerId);
                    if (p) {
                        p.points = data.points;
                        if (p.points < 10) p.alive = false;
                    }
                    updatePlayerList();
                    showFloatingResult(data.binX, data.multiplier, data.diff);
                    break;
                case 'error':
                    if (data.targetId && data.targetId !== myId) return;
                    showAlert(data.msg, "Error", () => location.reload());
                    break;
                case 'kick':
                    if (data.targetId === myId) {
                        showAlert("You have been kicked by the host.", "Kicked", () => location.reload());
                    }
                    break;
                case 'game_end':
                    // Transition to new room after game ends
                    showAlert(`ðŸŽ® Game Over! ðŸ†\n\nWinner: ${data.winner}\n\nReturning to lobby...`, "Result", () => location.reload());
                    break;
            }
        }


        function handleDisconnect(peerId) {
            if (peerId === myId) return; // Safety: Never disconnect ourselves
            console.log("handleDisconnect called for:", peerId);
            const index = players.findIndex(p => p.id === peerId);
            if (index === -1) {
                console.log("Player not found in list for disconnect:", peerId);
                return;
            }
            const wasTheirTurn = (index === turnIndex);

            console.log(`Disconnecting player at index ${index}. Turn was ${turnIndex}.`);

            players.splice(index, 1);
            if (players.length <= 1 && gameActive) {
                broadcast({ type: 'error', msg: "Game ended prematurely: No other players remaining." });
                showAlert("All other players left. Game Over!", "Game Over", () => location.reload());
                return;
            }
            if (gameActive) {
                if (wasTheirTurn) {
                    turnIndex--;
                    if (turnIndex < -1) turnIndex = -1;
                    nextTurn(true);
                } else if (index < turnIndex) {
                    turnIndex--;
                }
                broadcastPlayers();
                broadcastSync();
                updateTurnUI();
            } else {
                // Lobby phase: just sync the list
                broadcastPlayers();
                updatePlayerList();
                console.log("Lobby Sync: Player left, broadcasting new list. Current count:", players.length);
            }
        }


        function broadcastSync() {
            broadcast({ type: 'sync_round', round: currentRound, turnIndex, obstacles: currentObstacles });
        }

        function broadcast(data) {
            if (channel) {
                channel.publish('msg', data);
            }
        }

        function broadcastPlayers() {
            const list = players.map(p => ({ id: p.id, name: p.name, points: p.points, isHost: p.isHost, alive: p.alive }));
            broadcast({ type: 'players', players: list, maxPlayers: maxPlayersLimit });
        }

        function kickPlayer(playerId) {
            if (!isHost) return;
            console.log("Host kicking player:", playerId);

            // Send kick message to the player
            broadcast({ type: 'kick', targetId: playerId });

            // Remove from local list
            handleDisconnect(playerId);
        }

        // --- Game Logic ---
        function setRisk(divider) {
            const me = players.find(p => p.id === myId);
            if (me) {
                const riskInput = document.getElementById('risk-input');
                let amount;
                if (divider === 1) {
                    amount = Math.floor(me.points);
                } else {
                    amount = Math.ceil(me.points / divider);
                }
                // Enforce Min 10
                riskInput.value = Math.max(10, amount);
            }
        }

        function startGame() {
            if (!isHost) return;
            gameActive = true;
            turnIndex = Math.floor(Math.random() * players.length); // Random start
            currentObstacles = generateObstacles(getRowsForRound(currentRound));
            broadcast({ type: 'start', obstacles: currentObstacles, turnIndex });
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('main-game').style.display = 'flex';
            initGame(true); // Force first init
            updateTurnUI();
        }

        function initGame(force = false) {
            const rows = getRowsForRound(currentRound);

            // Always clear timeouts (Cleanup Phase)
            activeTimeouts.forEach(t => clearTimeout(t));
            activeTimeouts = [];

            // Smart Re-init: Only populate if forcing or if difficulty/round changed
            // NOTE: We do NOT destroy the renderer. We just clear the WORLD.
            if (!force && rows === lastInitedRows && currentRound === lastInitedRound) {
                updateHeader();
                return;
            }

            lastInitedRows = rows;
            lastInitedRound = currentRound;

            World.clear(engine.world, false); // Keep the engine running, just remove bodies

            createBoard(rows);
            createBins(rows);
            updateHeader();
        }

        function getRowsForRound(r) {
            if (r <= 2) return 8;
            if (r <= 4) return 12;
            return 16;
        }

        function getMultipliersForRound(r) {
            if (r >= 12) return config.multipliers.impossible;
            if (r >= 7) return config.multipliers.insane;
            if (r >= 5) return config.multipliers[16];
            if (r >= 3) return config.multipliers[12];
            return config.multipliers[8];
        }

        function generateObstacles(rows) {
            const obs = [];
            if (currentRound < 5) return obs; // Start obstacles at Hard (R5)
            const startX = config.width / 2;
            const totalBoardHeight = config.height - 150;
            const startY = 40;

            if (currentRound >= 12) {
                // IMPOSSIBLE: Two split bars with a gap in the center
                const gap = 80;
                const barWidth = 140;
                obs.push({ x: startX - (barWidth / 2 + gap / 2), y: startY + (totalBoardHeight * 0.5), width: barWidth, height: 15, isX0: true });
                obs.push({ x: startX + (barWidth / 2 + gap / 2), y: startY + (totalBoardHeight * 0.5), width: barWidth, height: 15, isX0: true });
            } else if (currentRound >= 7) {
                // INSANE: 5 random red bricks
                for (let i = 0; i < 5; i++) {
                    obs.push({
                        x: startX + (Math.random() * 400 - 200),
                        y: startY + (totalBoardHeight * 0.3) + (Math.random() * (totalBoardHeight * 0.5)),
                        angle: Math.random() * Math.PI,
                        width: 50, height: 10
                    });
                }
            } else {
                // HARD: 3 random bricks in the center (New!)
                for (let i = 0; i < 3; i++) {
                    obs.push({
                        x: startX + (Math.random() * 100 - 50), // Tighter center focus
                        y: startY + (totalBoardHeight * 0.4) + (i * 60),
                        angle: Math.random() * Math.PI,
                        width: 40, height: 8
                    });
                }
            }
            return obs;
        }

        function getUniqueName(baseName) {
            let name = baseName;
            let count = 2;
            while (players.some(p => p.name === name)) {
                name = `${baseName} (${count})`;
                count++;
            }
            return name;
        }

        function generateShortId() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let result = 'PR-';
            for (let i = 0; i < 4; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function updateHeader() {
            const r = currentRound;
            const badge = document.getElementById('diff-badge');
            let txt = "EASY";
            let color = "#00e701";

            if (r >= 3) { txt = "MEDIUM"; color = "#ffea00"; }
            if (r >= 5) { txt = "HARD"; color = "#ff9100"; }
            if (r >= 7) { txt = "INSANE"; color = "#ff1744"; }
            if (r >= 12) { txt = "IMPOSSIBLE"; color = "#6200ea"; }

            badge.innerText = txt;
            badge.style.background = color;
            document.getElementById('round-number').innerText = `ROUND ${r}`;
        }

        function updateTurnUI() {
            const currentPlayer = players[turnIndex];
            if (!currentPlayer) return;
            const isMyTurn = currentPlayer.id === myId;

            document.getElementById('drop-btn').disabled = !isMyTurn || !currentPlayer.alive;
            document.getElementById('status-text').innerText = isMyTurn ? "Your turn to drop!" : `Waiting for ${currentPlayer.name}...`;

            updatePlayerList();
        }

        function updatePlayerList() {
            const countEl = document.getElementById('player-count');
            if (countEl) countEl.innerText = `Players: ${players.length}/${maxPlayersLimit}`;
            const startBtn = document.getElementById('start-game-btn');
            if (startBtn && isHost) startBtn.disabled = players.length < 2;

            // Sort players by points (descending) for leaderboard
            const sortedPlayers = [...players].sort((a, b) => b.points - a.points);

            // Update lobby player list (if visible)
            const lobbyContainer = document.getElementById('lobby-player-list');
            if (lobbyContainer) {
                lobbyContainer.innerHTML = '';
                sortedPlayers.forEach((p, idx) => {
                    const div = document.createElement('div');
                    div.className = 'player-item';

                    const kickBtn = (isHost && !p.isHost) ?
                        `<button onclick="kickPlayer('${p.id}')" style="margin-left: auto; padding: 4px 8px; background: #ff1744; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.7rem;">KICK</button>` : '';

                    div.innerHTML = `
                        <span>${idx + 1}. ${p.name}${p.id === myId ? ' (You)' : ''}</span>
                        ${kickBtn}
                    `;
                    lobbyContainer.appendChild(div);
                });
            }

            // Update game player list (if visible) - show all players
            const container = document.getElementById('player-list');
            if (!container) return;
            container.innerHTML = '';

            sortedPlayers.forEach((p, idx) => {
                const div = document.createElement('div');

                // Find original index for turn indicator
                const originalIdx = players.findIndex(pl => pl.id === p.id);

                let statusTag = '';
                let extraClass = '';
                const isSpectator = !p.alive && p.points === 0;

                if (!p.alive) {
                    extraClass = 'eliminated';
                    // Distinguish between mid-game joiner (spectator) and loser
                    statusTag = isSpectator ?
                        '<span style="font-size: 0.6rem; color: #888; margin-bottom: 2px;">[SPECTATING]</span>' :
                        '<span style="font-size: 0.6rem; color: #ff1744; margin-bottom: 2px;">[OUT]</span>';
                }

                div.className = `player-item ${originalIdx === turnIndex ? 'active' : ''} ${extraClass}`;

                // Style adjustment: ensure text is dimmed but layout remains clean
                if (extraClass) {
                    div.style.color = "rgba(255,255,255,0.4)";
                }

                const kickBtn = (isHost && !p.isHost) ?
                    `<button onclick="kickPlayer('${p.id}')" style="margin-left: auto; padding: 4px 8px; background: #ff1744; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.7rem; box-shadow: 0 0 10px rgba(255, 23, 68, 0.3); flex-shrink: 0;">KICK</button>` : '';

                const pointsHtml = isSpectator ? '' : `<span style="font-weight:900; min-width: 40px; text-align: right;">${Math.floor(p.points)}</span>`;

                div.innerHTML = `
                    <div style="display: flex; flex-direction: column; flex-grow: 1;">
                        <span style="font-size: 0.9rem;">${idx + 1}. ${p.name}${p.id === myId ? ' (You)' : ''}</span>
                        ${statusTag}
                    </div>
                    <div style="display: flex; align-items: center; gap: 12px; pointer-events: auto;">
                        ${kickBtn}
                        ${pointsHtml}
                    </div>
                `;
                container.appendChild(div);
                if (p.id === myId) {
                    document.getElementById('my-score').innerText = Math.floor(p.points);
                }
            });
        }

        function emitDrop() {
            let risk = parseFloat(document.getElementById('risk-input').value) || 0;
            const me = players.find(p => p.id === myId);

            if (risk < 10) risk = 10;
            if (risk > me.points) risk = me.points;
            document.getElementById('risk-input').value = Math.floor(risk);

            const x = (config.width / 2) + (Math.random() * 10 - 5);
            if (isHost) {
                handleDropLogic(x, myId, risk);
            } else {
                broadcast({ type: 'drop_ball', x, playerId: myId, points: risk });
            }
            document.getElementById('drop-btn').disabled = true;
        }

        function handleDropLogic(x, playerId, risk) {
            broadcast({ type: 'drop_ball', x, playerId, points: risk });
            visualizeDrop(x, playerId, risk);
        }

        function visualizeDrop(x, playerId, risk) {
            const ball = Bodies.circle(x, 15, config.ballSize, {
                restitution: 0.5, friction: 0.05,
                render: { fillStyle: playerId === myId ? '#00e701' : '#ff4d4d' }
            });
            World.add(engine.world, ball);

            let completed = false;
            let setX0 = false;

            const finalizeLanding = () => {
                if (completed) return;
                completed = true;

                const relativeX = Math.min(Math.max(ball.position.x, 20), config.width - 20);
                const mList = getMultipliersForRound(currentRound);
                const binAreaWidth = config.width - 60;
                const binIndex = Math.floor(((relativeX - 30) / binAreaWidth) * mList.length);
                const finalIdx = Math.min(Math.max(binIndex, 0), mList.length - 1);

                let multiplier = setX0 ? 0 : mList[finalIdx];
                const diff = (risk * multiplier) - risk;

                if (isHost) {
                    const p = players.find(x => x.id === playerId);
                    if (p) {
                        p.points += diff;
                        if (p.points <= 0) p.points = 0;
                        broadcast({ type: 'score_update', playerId, points: p.points, multiplier, diff, binX: ball.position.x });
                        showFloatingResult(ball.position.x, multiplier, diff);
                    }
                    nextTurn();
                }

                const bins = document.querySelectorAll('.bin');
                if (!setX0 && bins[finalIdx]) {
                    bins[finalIdx].classList.add('active');
                    setTimeout(() => bins[finalIdx].classList.remove('active'), 200);
                }
                World.remove(engine.world, ball);
                Events.off(engine, "afterUpdate", checkLanding);
            };

            const timeout = setTimeout(() => {
                if (!completed) finalizeLanding();
            }, 8000); // 8s timeout
            activeTimeouts.push(timeout);

            const checkLanding = () => {
                if (currentRound >= 12) {
                    currentObstacles.forEach(obs => {
                        if (obs.isX0) {
                            const dx = ball.position.x - obs.x;
                            const dy = ball.position.y - obs.y;
                            if (Math.abs(dx) < obs.width / 2 && Math.abs(dy) < obs.height / 2) {
                                setX0 = true;
                                finalizeLanding();
                            }
                        }
                    });
                }

                if (ball.position.y > config.height - 50) {
                    clearTimeout(timeout);
                    finalizeLanding();
                }
            };
            Events.on(engine, "afterUpdate", checkLanding);
        }

        function nextTurn(skipSync = false) {
            if (!isHost) return;

            let loopLimit = players.length;
            do {
                turnIndex++;
                if (turnIndex >= players.length) {
                    turnIndex = 0;
                    currentRound++;

                    const alivePlayers = players.filter(p => p.points >= 10); // Min 10 to survive
                    if (alivePlayers.length <= 1 || currentRound > 16) {
                        let winnerName = "";
                        if (alivePlayers.length === 1) {
                            winnerName = alivePlayers[0].name;
                        } else if (alivePlayers.length > 1) {
                            let maxPts = -1;
                            let tied = false;
                            alivePlayers.forEach(p => {
                                if (p.points > maxPts) { maxPts = p.points; winnerName = p.name; tied = false; }
                                else if (p.points === maxPts) { tied = true; }
                            });
                            winnerName = tied ? "TIE - Multiple Winners!" : winnerName;
                        } else {
                            winnerName = "No survivors";
                        }

                        // Broadcast game end to all players
                        broadcast({ type: 'game_end', winner: winnerName });

                        // Host also sees the message
                        showAlert(`ðŸŽ® Game Over! ðŸ†\n\nWinner: ${winnerName}\n\nReturning to lobby...`, "Result", () => location.reload());
                        return;
                    }

                    currentObstacles = generateObstacles(getRowsForRound(currentRound));
                    initGame(); // Rebuild for new round
                    break;
                }
                loopLimit--;
            } while (players[turnIndex] && players[turnIndex].points < 10 && loopLimit >= 0); // Skip if < 10

            if (!skipSync) {
                broadcastSync();
                updateTurnUI();
            }
        }

        function showFloatingResult(x, mult, diff) {
            const wrapper = document.getElementById('canvas-wrapper');
            const div = document.createElement('div');
            div.className = 'floating-text';
            div.style.left = `${x}px`;
            div.style.bottom = `60px`;
            if (mult >= 5) {
                div.innerText = `WIN x${mult} (+${diff.toFixed(0)})`;
                div.classList.add('gold-win');
            } else if (mult >= 1) {
                div.innerText = `+${diff.toFixed(0)}`;
                div.classList.add('green-win');
            } else {
                div.innerText = `-${Math.abs(diff).toFixed(0)}`;
                div.classList.add('loss-text');
            }
            wrapper.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        function createBoard(rows) {
            const startX = config.width / 2;
            const totalBoardHeight = config.height - 150;
            const startY = 40;
            const vSpacing = totalBoardHeight / rows;
            const hSpacing = Math.min(vSpacing, 48);

            for (let i = 0; i < rows; i++) {
                const rowCount = i + 3;
                const rowWidth = (rowCount - 1) * hSpacing;
                const xOffset = startX - rowWidth / 2;
                for (let j = 0; j < rowCount; j++) {
                    World.add(engine.world, Bodies.circle(xOffset + j * hSpacing, startY + (i * vSpacing), config.pegSize, {
                        isStatic: true, render: { fillStyle: '#4a6a7d' }, friction: 0, restitution: 0.6
                    }));
                }
            }

            currentObstacles.forEach(obs => {
                const body = Bodies.rectangle(obs.x, obs.y, obs.width, obs.height, {
                    isStatic: true,
                    render: { fillStyle: obs.isX0 ? '#111' : '#c7254e' },
                    restitution: obs.isX0 ? 0 : 1.5,
                    angle: obs.angle || 0
                });
                World.add(engine.world, body);
            });

            World.add(engine.world, [
                Bodies.rectangle(2, config.height / 2, 4, config.height, { isStatic: true, render: { visible: false } }),
                Bodies.rectangle(config.width - 2, config.height / 2, 4, config.height, { isStatic: true, render: { visible: false } })
            ]);
        }

        function createBins(rows) {
            const row = document.getElementById('bins-row');
            row.innerHTML = '';
            const mList = getMultipliersForRound(currentRound);
            mList.forEach(m => {
                const div = document.createElement('div');
                div.className = 'bin';
                div.innerText = m + 'x';
                div.style.background = m < 1 ? '#cc4d29' : (m >= 5 ? '#00bc00' : '#627d14');
                row.appendChild(div);
            });
        }

        let alertCallback = null;
        function showAlert(msg, title = "Notification", callback = null) {
            document.getElementById('alert-msg').innerText = msg;
            document.querySelector('.alert-title').innerText = title;
            document.getElementById('custom-alert').style.display = 'flex';
            alertCallback = callback;
        }

        function closeAlert() {
            document.getElementById('custom-alert').style.display = 'none';
            if (alertCallback) {
                alertCallback();
                alertCallback = null;
            }
        }

    </script>
</body>

</html>
