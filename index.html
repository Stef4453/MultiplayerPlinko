<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plinko Multiplayer</title>
    <!-- Matter.js for physics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <!-- Ably for Realtime Messaging Relay -->
    <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
    <style>
        :root {
            --bg-color: #0d1e29;
            --panel-color: #1a2c38;
            --accent-color: #00e701;
            --ball-color: #ff4d4d;
            --text-color: #ffffff;
            --secondary-text: #b1bad3;
            --peg-color: #4a6a7d;
            --obstacle-color: #c7254e;
            --input-bg: #0f212e;
            --gold-color: #ffca28;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* Lobby & General UI */
        #lobby-screen {
            position: fixed;
            inset: 0;
            background: var(--bg-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .lobby-card {
            background: var(--panel-color);
            padding: 20px;
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            border: 1px solid #2f4553;
            text-align: center;
        }

        .input-box {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            border: 2px solid #2f4553;
            background: var(--input-bg);
            color: white;
            box-sizing: border-box;
            font-size: 1rem;
        }

        /* Game Structure */
        .game-container {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: row;
        }

        .side-panel {
            width: 320px;
            background: #213743;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            border-right: 1px solid #2f4553;
            overflow-y: auto;
        }

        .board-container {
            flex: 1;
            position: relative;
            background: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        /* Player List */
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #1a2c38;
            border-radius: 8px;
            margin-bottom: 8px;
            border: 1px solid transparent;
            transition: all 0.3s;
        }

        .player-item.active {
            border-color: var(--accent-color);
            box-shadow: 0 0 10px rgba(0, 231, 1, 0.2);
        }

        .player-item.eliminated {
            opacity: 0.5;
            background: #111;
        }

        /* Round Header */
        .round-info {
            text-align: center;
            margin-bottom: 10px;
        }

        .round-badge {
            background: var(--accent-color);
            color: #000;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: 900;
            text-transform: uppercase;
        }

        /* Bins */
        #canvas-wrapper {
            position: relative;
            width: 700px;
            height: 600px;
        }

        .bins-container {
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 2px;
            padding: 0 10px;
            pointer-events: none;
        }

        .bin {
            flex: 1;
            min-width: 0;
            height: 35px;
            background: #2f4553;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.75rem;
            font-weight: 800;
            color: #fff;
            transition: transform 0.1s;
            overflow: hidden;
            white-space: nowrap;
        }

        .bin.active {
            background: var(--accent-color) !important;
            color: #000;
            transform: scale(1.1);
        }

        /* Responsive UI */
        @media (max-width: 900px) {
            .game-container {
                flex-direction: column;
                overflow-y: auto;
            }

            .side-panel {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #2f4553;
                box-sizing: border-box;
            }

            #canvas-wrapper {
                width: 100% !important;
                max-width: 700px;
                height: auto !important;
                aspect-ratio: 7/6;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
            }

            .board-container {
                padding: 10px;
                width: 100%;
                box-sizing: border-box;
            }

            .side-panel {
                padding: 10px;
                gap: 10px;
            }

            #my-score {
                font-size: 1.5rem !important;
            }

            .player-item {
                padding: 8px;
                font-size: 0.9rem;
            }
        }

        /* Floating Text Animations */
        @keyframes float-up {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }

        .floating-text {
            position: absolute;
            pointer-events: none;
            font-weight: 900;
            animation: float-up 1s forwards;
            z-index: 100;
        }

        .gold-win {
            color: #ffca28;
            text-shadow: 0 0 10px rgba(255, 202, 40, 0.5);
            font-size: 2rem;
        }

        .green-win {
            color: #00e701;
            font-size: 1.2rem;
        }

        .loss-text {
            color: #ff4d4d;
            font-size: 1rem;
        }

        /* Buttons */
        button {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
        }

        .btn-primary {
            background: var(--accent-color);
            color: #000;
        }

        .btn-secondary {
            background: #2f4553;
            color: white;
        }

        button:disabled {
            background: #111;
            color: #444;
            cursor: not-allowed;
        }

        #room-id-display {
            background: #0d1e29;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            margin: 10px 0;
            display: block;
            word-break: break-all;
        }

        .risk-presets {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 5px;
        }

        .risk-presets button {
            padding: 8px;
            font-size: 0.7rem;
            border-radius: 4px;
        }
    </style>
</head>

<body>

    <div id="lobby-screen">
        <div class="lobby-card">
            <h1>Plinko Multiplayer</h1>
            <input type="text" id="name-input" class="input-box" placeholder="Your Name" maxlength="12">
            <div id="pre-room">
                <div style="margin: 10px 0; display: flex; align-items: center; gap: 10px; justify-content: center;">
                    <label for="max-players-input" style="color: #ccc; font-size: 0.9em;">Max Players:</label>
                    <input type="number" id="max-players-input" min="2" max="16" value="8"
                        style="width: 60px; padding: 8px; text-align: center;">
                </div>
                <button onclick="hostGame()" class="btn-primary" style="width: 100%">Host New Game</button>
                <div style="margin: 15px 0; color: var(--secondary-text)">— OR —</div>
                <input type="text" id="join-room-id" class="input-box" placeholder="Enter Room ID">
                <button onclick="joinGame()" class="btn-secondary" style="width: 100%">Join Game</button>
            </div>
            <div id="wait-room" style="display: none;">
                <p>Room ID: <span id="room-id-display">Generating...</span></p>
                <p id="player-count">Players: 1/8</p>
                <button onclick="startGame()" id="start-game-btn" class="btn-primary"
                    style="background: #00e701; color: #000; margin-top: 15px;">START GAME</button>
            </div>
        </div>
    </div>

    <div
        style="position: fixed; bottom: 10px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 0.8rem; pointer-events: none; z-index: 9999;">
        Plinko Multiplayer. Vibe Coded by Stef using Antigravity. <a
            href="https://github.com/Stef4453/MultiplayerPlinko" target="_blank"
            style="color: rgba(255,255,255,0.8); text-decoration: none; pointer-events: auto;">GitHub Repo</a>
    </div>

    <div class="game-container" id="main-game">
        <div class="side-panel">
            <div class="round-info">
                <div class="round-badge" id="diff-badge">EASY</div>
                <h2 id="round-number">ROUND 1</h2>
            </div>

            <div id="player-list">
                <!-- Syncing players here -->
            </div>

            <div style="margin-top: auto;">
                <div class="label">Your Points</div>
                <div id="my-score" style="font-size: 2rem; font-weight: 900; color: var(--accent-color);">1000</div>

                <div class="control-group" style="margin-top: 15px;">
                    <div class="label">Amount to Risk</div>
                    <div style="display: flex; gap: 8px;">
                        <input type="number" id="risk-input" class="input-box" value="10" min="10"
                            style="margin: 0; flex: 1;">
                        <button onclick="setRisk(1)" class="btn-secondary" style="padding: 10px;">MAX</button>
                    </div>
                    <div class="risk-presets">
                        <button onclick="setRisk(2)" class="btn-secondary">1/2</button>
                        <button onclick="setRisk(4)" class="btn-secondary">1/4</button>
                        <button onclick="setRisk(8)" class="btn-secondary">1/8</button>
                    </div>
                </div>
                <button id="drop-btn" onclick="emitDrop()" class="btn-primary"
                    style="width: 100%; margin-top: 10px;">DROP!</button>
            </div>
        </div>

        <div class="board-container">
            <div id="status-text"
                style="margin-bottom: 10px; color: var(--secondary-text); font-weight: bold; background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 20px;">
                Waiting for players...</div>
            <div id="canvas-wrapper">
                <div class="bins-container" id="bins-row"></div>
            </div>
        </div>
    </div>

    <script>
        // --- State & Config ---
        const config = {
            width: 700,
            height: 600,
            pegSize: 5,
            ballSize: 7,
            multipliers: {
                8: [5.6, 2.1, 1.1, 0.5, 0.2, 0.5, 1.1, 2.1, 5.6],
                12: [33, 11, 4.4, 2.1, 1.1, 0.5, 0.2, 0.5, 1.1, 2.1, 4.4, 11, 33],
                16: [110, 41, 10, 5, 3, 1.5, 1, 0.5, 0.2, 0.5, 1, 1.5, 3, 5, 10, 41, 110],
                // Specific Overrides
                insane: [110, 41, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.2, 0.5, 1, 2, 5, 10, 41, 110],
                impossible: [1000, 500, 100, 10, 2, 0.5, 0.2, 0.1, 0.1, 0.1, 0.2, 0.5, 2, 10, 100, 500, 1000]
            }
        };

        // --- DON'T EVEN BOTHER STEALING IT - YOU WON'T BE ABLE TO DO MUCH ANYWAY -Stef ---
        const ABLY_KEY = 'Wwc3Hw.ZDnKdg:aX6tvLkW4-tIKleXroX-f4YacnGk5uNzEmMrJ3q13D8';
        let ably, channel;

        // ... variables ...
        let myId;
        let myName = "Player";
        let isHost = false;
        let players = [];
        let gameActive = false;
        let turnIndex = 0;
        let currentRound = 1;
        let currentObstacles = [];
        let activeTimeouts = [];
        let lastInitedRows = 0;
        let lastInitedRound = 0;
        let maxPlayersLimit = 8;

        // --- Persistent Matter.js Engine ---
        const { Engine, Render, Runner, Bodies, Composite, World, Events } = Matter;
        const engine = Engine.create();
        engine.world.gravity.y = 1.0;
        const runner = Runner.create();
        let render;

        // Initialize Renderer immediately (Persistent)
        window.addEventListener('load', () => {
            const cw = document.getElementById('canvas-wrapper');
            render = Render.create({
                element: cw,
                engine: engine,
                options: { width: config.width, height: config.height, wireframes: false, background: 'transparent' }
            });
            Render.run(render);
            Runner.run(runner, engine);
        });

        // --- Networking (Ably) ---
        function hostGame() {
            myName = document.getElementById('name-input').value || "Host";
            const val = parseInt(document.getElementById('max-players-input').value);
            maxPlayersLimit = (val && val >= 2) ? val : 8;

            const roomCode = generateShortId();
            initAbly(roomCode, true);
        }

        function joinGame() {
            let roomCode = document.getElementById('join-room-id').value;
            if (!roomCode) return alert("Please enter a Room ID");
            roomCode = roomCode.trim().toUpperCase();

            myName = document.getElementById('name-input').value || "Guest";
            initAbly(roomCode, false);
        }

        function initAbly(roomCode, hosting) {
            isHost = hosting;
            myId = Math.random().toString(36).substr(2, 9);

            ably = new Ably.Realtime({ key: ABLY_KEY, clientId: myId });
            channel = ably.channels.get(`plinko_${roomCode}`);

            ably.connection.on('connected', () => {
                if (hosting) {
                    isHost = true;
                    myName = getUniqueName(myName);
                    document.getElementById('room-id-display').innerText = roomCode;
                    document.getElementById('pre-room').style.display = 'none';
                    document.getElementById('wait-room').style.display = 'block';
                    players = [{ id: myId, name: myName, points: 1000, isHost: true, alive: true }];
                    updatePlayerList();
                }

                // Subscribe to messages
                channel.subscribe(msg => {
                    if (msg.clientId === myId) return; // Ignore self
                    handleMessage(msg.data);
                });

                // Presence tracking
                channel.presence.subscribe('enter', member => {
                    console.log("Presence: Member entered", member.clientId, member.data);
                    if (isHost && member.clientId !== myId) {
                        // When someone enters the channel, ensure they get a fresh player list
                        broadcastPlayers();
                    }
                });

                channel.presence.subscribe('leave', member => {
                    console.log("Presence: Member left", member.clientId, member.data);
                    if (isHost) {
                        handleDisconnect(member.clientId);
                    } else {
                        // Much more robust Host detection: check for isHost flag in presence data
                        if (member.data && member.data.isHost) {
                            console.log("Presence Guard: Detected Host departure.");
                            alert("Host has left the room. Returning to lobby.");
                            location.reload();
                        }
                    }
                });

                channel.presence.enter({ name: myName, isHost: isHost });

                // Host-only networking maintenance
                if (hosting) {
                    // 1. Keep-Alive Heartbeat (every 15s)
                    setInterval(() => {
                        if (channel) broadcast({ type: 'heartbeat' });
                    }, 15000);

                    // 2. Presence Sync Guard (every 5s)
                    setInterval(() => {
                        channel.presence.get((err, members) => {
                            if (!err && members) {
                                const currentAblyIds = members.map(m => m.clientId);

                                // SELF-VERIFY: If host isn't in the list, the list might be stale. Do NOT kick.
                                if (!currentAblyIds.includes(myId)) {
                                    console.log("Presence Guard: Local Host ID not found in presence list yet.");
                                    return;
                                }
                                for (let i = players.length - 1; i >= 0; i--) {
                                    const p = players[i];
                                    if (p.isHost) continue; // Don't disconnect host

                                    // 15s grace period for newly joined players to register with Ably
                                    if (Date.now() - (p.joinedAt || 0) < 15000) continue;

                                    if (!currentAblyIds.includes(p.id)) {
                                        console.log("Presence Guard: Player missing - triggering disconnect", p.id);
                                        handleDisconnect(p.id);
                                    }
                                }
                            }
                        });
                    }, 5000);
                }

                window.addEventListener('beforeunload', () => {
                    if (channel) channel.presence.leave();
                });

                if (!hosting) {
                    broadcast({ type: 'join', name: myName, id: myId });
                    document.getElementById('pre-room').style.display = 'none';
                    document.getElementById('wait-room').style.display = 'block';
                    document.getElementById('start-game-btn').style.display = 'none';
                    document.getElementById('room-id-display').innerText = roomCode;
                    updatePlayerList(); // Initial update for guest
                }
            });

            ably.connection.on('failed', () => alert("Connection to Ably failed!"));
        }

        function handleMessage(data) {
            switch (data.type) {
                case 'join':
                    if (isHost) {
                        if (players.length >= maxPlayersLimit) {
                            broadcast({ type: 'error', msg: "Room is full!", targetId: data.id });
                            return;
                        }
                        const newName = getUniqueName(data.name);
                        players.push({ id: data.id, name: newName, points: 1000, isHost: false, alive: true, joinedAt: Date.now() });
                        broadcastPlayers();
                        updatePlayerList();
                    }
                    break;
                case 'heartbeat':
                    // Keep-alive message to maintain active connection
                    break;
                case 'players':
                    players = data.players;
                    if (data.maxPlayers) maxPlayersLimit = data.maxPlayers;
                    updatePlayerList();
                    break;
                case 'start':
                    gameActive = true;
                    currentObstacles = data.obstacles || [];
                    turnIndex = data.turnIndex !== undefined ? data.turnIndex : 0;
                    document.getElementById('lobby-screen').style.display = 'none';
                    document.getElementById('main-game').style.display = 'flex';
                    initGame(true);
                    updateTurnUI();
                    break;
                case 'sync_round':
                    currentRound = data.round;
                    turnIndex = data.turnIndex;
                    currentObstacles = data.obstacles || [];
                    initGame();
                    updateTurnUI();
                    break;
                case 'drop_ball':
                    if (isHost) {
                        handleDropLogic(data.x, data.playerId, data.points);
                    } else {
                        visualizeDrop(data.x, data.playerId, data.points);
                    }
                    break;
                case 'score_update':
                    const p = players.find(x => x.id === data.playerId);
                    if (p) {
                        p.points = data.points;
                        if (p.points < 10) p.alive = false;
                    }
                    updatePlayerList();
                    showFloatingResult(data.binX, data.multiplier, data.diff);
                    break;
                case 'error':
                    if (data.targetId && data.targetId !== myId) return;
                    alert(data.msg);
                    location.reload();
                    break;
            }
        }


        function handleDisconnect(peerId) {
            if (peerId === myId) return; // Safety: Never disconnect ourselves
            console.log("handleDisconnect called for:", peerId);
            const index = players.findIndex(p => p.id === peerId);
            if (index === -1) {
                console.log("Player not found in list for disconnect:", peerId);
                return;
            }
            const wasTheirTurn = (index === turnIndex);

            console.log(`Disconnecting player at index ${index}. Turn was ${turnIndex}.`);

            players.splice(index, 1);
            if (players.length <= 1 && gameActive) {
                broadcast({ type: 'error', msg: "Game ended prematurely: No other players remaining." });
                alert("All other players left. Game Over!");
                location.reload();
                return;
            }
            if (gameActive) {
                if (wasTheirTurn) {
                    turnIndex--;
                    if (turnIndex < -1) turnIndex = -1;
                    nextTurn(true);
                } else if (index < turnIndex) {
                    turnIndex--;
                }
                broadcastPlayers();
                broadcastSync();
                updateTurnUI();
            } else {
                // Lobby phase: just sync the list
                broadcastPlayers();
                updatePlayerList();
                console.log("Lobby Sync: Player left, broadcasting new list. Current count:", players.length);
            }
        }


        function broadcastSync() {
            broadcast({ type: 'sync_round', round: currentRound, turnIndex, obstacles: currentObstacles });
        }

        function broadcast(data) {
            if (channel) {
                channel.publish('msg', data);
            }
        }

        function broadcastPlayers() {
            const list = players.map(p => ({ id: p.id, name: p.name, points: p.points, isHost: p.isHost, alive: p.alive }));
            broadcast({ type: 'players', players: list, maxPlayers: maxPlayersLimit });
        }

        // --- Game Logic ---
        function setRisk(divider) {
            const me = players.find(p => p.id === myId);
            if (me) {
                const riskInput = document.getElementById('risk-input');
                let amount;
                if (divider === 1) {
                    amount = Math.floor(me.points);
                } else {
                    amount = Math.ceil(me.points / divider);
                }
                // Enforce Min 10
                riskInput.value = Math.max(10, amount);
            }
        }

        function startGame() {
            if (!isHost) return;
            gameActive = true;
            turnIndex = Math.floor(Math.random() * players.length); // Random start
            currentObstacles = generateObstacles(getRowsForRound(currentRound));
            broadcast({ type: 'start', obstacles: currentObstacles, turnIndex });
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('main-game').style.display = 'flex';
            initGame(true); // Force first init
            updateTurnUI();
        }

        function initGame(force = false) {
            const rows = getRowsForRound(currentRound);

            // Always clear timeouts (Cleanup Phase)
            activeTimeouts.forEach(t => clearTimeout(t));
            activeTimeouts = [];

            // Smart Re-init: Only populate if forcing or if difficulty/round changed
            // NOTE: We do NOT destroy the renderer. We just clear the WORLD.
            if (!force && rows === lastInitedRows && currentRound === lastInitedRound) {
                updateHeader();
                return;
            }

            lastInitedRows = rows;
            lastInitedRound = currentRound;

            World.clear(engine.world, false); // Keep the engine running, just remove bodies

            createBoard(rows);
            createBins(rows);
            updateHeader();
        }

        function getRowsForRound(r) {
            if (r <= 2) return 8;
            if (r <= 4) return 12;
            return 16;
        }

        function getMultipliersForRound(r) {
            if (r >= 12) return config.multipliers.impossible;
            if (r >= 7) return config.multipliers.insane;
            if (r >= 5) return config.multipliers[16];
            if (r >= 3) return config.multipliers[12];
            return config.multipliers[8];
        }

        function generateObstacles(rows) {
            const obs = [];
            if (currentRound < 5) return obs; // Start obstacles at Hard (R5)
            const startX = config.width / 2;
            const totalBoardHeight = config.height - 150;
            const startY = 40;

            if (currentRound >= 12) {
                // IMPOSSIBLE: Two split bars with a gap in the center
                const gap = 80;
                const barWidth = 140;
                obs.push({ x: startX - (barWidth / 2 + gap / 2), y: startY + (totalBoardHeight * 0.5), width: barWidth, height: 15, isX0: true });
                obs.push({ x: startX + (barWidth / 2 + gap / 2), y: startY + (totalBoardHeight * 0.5), width: barWidth, height: 15, isX0: true });
            } else if (currentRound >= 7) {
                // INSANE: 5 random red bricks
                for (let i = 0; i < 5; i++) {
                    obs.push({
                        x: startX + (Math.random() * 400 - 200),
                        y: startY + (totalBoardHeight * 0.3) + (Math.random() * (totalBoardHeight * 0.5)),
                        angle: Math.random() * Math.PI,
                        width: 50, height: 10
                    });
                }
            } else {
                // HARD: 3 random bricks in the center (New!)
                for (let i = 0; i < 3; i++) {
                    obs.push({
                        x: startX + (Math.random() * 100 - 50), // Tighter center focus
                        y: startY + (totalBoardHeight * 0.4) + (i * 60),
                        angle: Math.random() * Math.PI,
                        width: 40, height: 8
                    });
                }
            }
            return obs;
        }

        function getUniqueName(baseName) {
            let name = baseName;
            let count = 2;
            while (players.some(p => p.name === name)) {
                name = `${baseName} (${count})`;
                count++;
            }
            return name;
        }

        function generateShortId() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let result = 'PR-';
            for (let i = 0; i < 4; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function updateHeader() {
            const r = currentRound;
            const badge = document.getElementById('diff-badge');
            let txt = "EASY";
            let color = "#00e701";

            if (r >= 3) { txt = "MEDIUM"; color = "#ffea00"; }
            if (r >= 5) { txt = "HARD"; color = "#ff9100"; }
            if (r >= 7) { txt = "INSANE"; color = "#ff1744"; }
            if (r >= 12) { txt = "IMPOSSIBLE"; color = "#6200ea"; }

            badge.innerText = txt;
            badge.style.background = color;
            document.getElementById('round-number').innerText = `ROUND ${r}`;
        }

        function updateTurnUI() {
            const currentPlayer = players[turnIndex];
            if (!currentPlayer) return;
            const isMyTurn = currentPlayer.id === myId;

            document.getElementById('drop-btn').disabled = !isMyTurn || !currentPlayer.alive;
            document.getElementById('status-text').innerText = isMyTurn ? "Your turn to drop!" : `Waiting for ${currentPlayer.name}...`;

            updatePlayerList();
        }

        function updatePlayerList() {
            const countEl = document.getElementById('player-count');
            if (countEl) countEl.innerText = `Players: ${players.length}/${maxPlayersLimit}`;
            const startBtn = document.getElementById('start-game-btn');
            if (startBtn && isHost) startBtn.disabled = players.length < 2;

            const container = document.getElementById('player-list');
            if (!container) return;
            container.innerHTML = '';
            players.forEach((p, idx) => {
                const div = document.createElement('div');
                div.className = `player-item ${idx === turnIndex ? 'active' : ''} ${!p.alive ? 'eliminated' : ''}`;
                div.innerHTML = `
                <span>${p.name}${p.id === myId ? ' (You)' : ''}</span>
                <span style="font-weight:900">${Math.floor(p.points)}</span>
            `;
                container.appendChild(div);
                if (p.id === myId) {
                    document.getElementById('my-score').innerText = Math.floor(p.points);
                    if (!p.alive) {
                        document.getElementById('drop-btn').disabled = true;
                        document.getElementById('status-text').innerText = "Eliminated!";
                    }
                }
            });
        }

        function emitDrop() {
            let risk = parseFloat(document.getElementById('risk-input').value) || 0;
            const me = players.find(p => p.id === myId);

            if (risk < 10) risk = 10;
            if (risk > me.points) risk = me.points;
            document.getElementById('risk-input').value = Math.floor(risk);

            const x = (config.width / 2) + (Math.random() * 10 - 5);
            if (isHost) {
                handleDropLogic(x, myId, risk);
            } else {
                broadcast({ type: 'drop_ball', x, playerId: myId, points: risk });
            }
            document.getElementById('drop-btn').disabled = true;
        }

        function handleDropLogic(x, playerId, risk) {
            broadcast({ type: 'drop_ball', x, playerId, points: risk });
            visualizeDrop(x, playerId, risk);
        }

        function visualizeDrop(x, playerId, risk) {
            const ball = Bodies.circle(x, 15, config.ballSize, {
                restitution: 0.5, friction: 0.05,
                render: { fillStyle: playerId === myId ? '#00e701' : '#ff4d4d' }
            });
            World.add(engine.world, ball);

            let completed = false;
            let setX0 = false;

            const finalizeLanding = () => {
                if (completed) return;
                completed = true;

                const relativeX = Math.min(Math.max(ball.position.x, 20), config.width - 20);
                const mList = getMultipliersForRound(currentRound);
                const binAreaWidth = config.width - 60;
                const binIndex = Math.floor(((relativeX - 30) / binAreaWidth) * mList.length);
                const finalIdx = Math.min(Math.max(binIndex, 0), mList.length - 1);

                let multiplier = setX0 ? 0 : mList[finalIdx];
                const diff = (risk * multiplier) - risk;

                if (isHost) {
                    const p = players.find(x => x.id === playerId);
                    if (p) {
                        p.points += diff;
                        if (p.points <= 0) p.points = 0;
                        broadcast({ type: 'score_update', playerId, points: p.points, multiplier, diff, binX: ball.position.x });
                        showFloatingResult(ball.position.x, multiplier, diff);
                    }
                    nextTurn();
                }

                const bins = document.querySelectorAll('.bin');
                if (!setX0 && bins[finalIdx]) {
                    bins[finalIdx].classList.add('active');
                    setTimeout(() => bins[finalIdx].classList.remove('active'), 200);
                }
                World.remove(engine.world, ball);
                Events.off(engine, "afterUpdate", checkLanding);
            };

            const timeout = setTimeout(() => {
                if (!completed) finalizeLanding();
            }, 8000); // 8s timeout
            activeTimeouts.push(timeout);

            const checkLanding = () => {
                if (currentRound >= 12) {
                    currentObstacles.forEach(obs => {
                        if (obs.isX0) {
                            const dx = ball.position.x - obs.x;
                            const dy = ball.position.y - obs.y;
                            if (Math.abs(dx) < obs.width / 2 && Math.abs(dy) < obs.height / 2) {
                                setX0 = true;
                                finalizeLanding();
                            }
                        }
                    });
                }

                if (ball.position.y > config.height - 50) {
                    clearTimeout(timeout);
                    finalizeLanding();
                }
            };
            Events.on(engine, "afterUpdate", checkLanding);
        }

        function nextTurn(skipSync = false) {
            if (!isHost) return;

            let loopLimit = players.length;
            do {
                turnIndex++;
                if (turnIndex >= players.length) {
                    turnIndex = 0;
                    currentRound++;

                    const alivePlayers = players.filter(p => p.points >= 10); // Min 10 to survive
                    if (alivePlayers.length <= 1 || currentRound > 16) {
                        let msg = "";
                        if (alivePlayers.length === 1) {
                            msg = `GAME OVER! Winner: ${alivePlayers[0].name}`;
                        } else if (alivePlayers.length > 1) {
                            let maxPts = -1;
                            let tied = false;
                            let winner = "";
                            alivePlayers.forEach(p => {
                                if (p.points > maxPts) { maxPts = p.points; winner = p.name; tied = false; }
                                else if (p.points === maxPts) { tied = true; }
                            });
                            msg = tied ? "GAME OVER! It's a TIE!" : `GAME OVER! Winner: ${winner}`;
                        } else {
                            msg = "GAME OVER! Everyone eliminated!";
                        }
                        broadcast({ type: 'error', msg });
                        alert(msg);
                        location.reload();
                        return;
                    }

                    currentObstacles = generateObstacles(getRowsForRound(currentRound));
                    initGame(); // Rebuild for new round
                    break;
                }
                loopLimit--;
            } while (players[turnIndex] && players[turnIndex].points < 10 && loopLimit >= 0); // Skip if < 10

            if (!skipSync) {
                broadcastSync();
                updateTurnUI();
            }
        }

        function showFloatingResult(x, mult, diff) {
            const wrapper = document.getElementById('canvas-wrapper');
            const div = document.createElement('div');
            div.className = 'floating-text';
            div.style.left = `${x}px`;
            div.style.bottom = `60px`;
            if (mult >= 5) {
                div.innerText = `WIN x${mult} (+${diff.toFixed(0)})`;
                div.classList.add('gold-win');
            } else if (mult >= 1) {
                div.innerText = `+${diff.toFixed(0)}`;
                div.classList.add('green-win');
            } else {
                div.innerText = `-${Math.abs(diff).toFixed(0)}`;
                div.classList.add('loss-text');
            }
            wrapper.appendChild(div);
            setTimeout(() => div.remove(), 1000);
        }

        function createBoard(rows) {
            const startX = config.width / 2;
            const totalBoardHeight = config.height - 150;
            const startY = 40;
            const vSpacing = totalBoardHeight / rows;
            const hSpacing = Math.min(vSpacing, 48);

            for (let i = 0; i < rows; i++) {
                const rowCount = i + 3;
                const rowWidth = (rowCount - 1) * hSpacing;
                const xOffset = startX - rowWidth / 2;
                for (let j = 0; j < rowCount; j++) {
                    World.add(engine.world, Bodies.circle(xOffset + j * hSpacing, startY + (i * vSpacing), config.pegSize, {
                        isStatic: true, render: { fillStyle: '#4a6a7d' }, friction: 0, restitution: 0.6
                    }));
                }
            }

            currentObstacles.forEach(obs => {
                const body = Bodies.rectangle(obs.x, obs.y, obs.width, obs.height, {
                    isStatic: true,
                    render: { fillStyle: obs.isX0 ? '#111' : '#c7254e' },
                    restitution: obs.isX0 ? 0 : 1.5,
                    angle: obs.angle || 0
                });
                World.add(engine.world, body);
            });

            World.add(engine.world, [
                Bodies.rectangle(2, config.height / 2, 4, config.height, { isStatic: true, render: { visible: false } }),
                Bodies.rectangle(config.width - 2, config.height / 2, 4, config.height, { isStatic: true, render: { visible: false } })
            ]);
        }

        function createBins(rows) {
            const row = document.getElementById('bins-row');
            row.innerHTML = '';
            const mList = getMultipliersForRound(currentRound);
            mList.forEach(m => {
                const div = document.createElement('div');
                div.className = 'bin';
                div.innerText = m + 'x';
                div.style.background = m < 1 ? '#cc4d29' : (m >= 5 ? '#00bc00' : '#627d14');
                row.appendChild(div);
            });
        }

    </script>
</body>

</html>
